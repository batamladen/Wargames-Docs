"use strict";(globalThis.webpackChunkwargames_docs=globalThis.webpackChunkwargames_docs||[]).push([[8861],{6439:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>u,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>i});const s=JSON.parse('{"id":"Architecture/Backend/Flask Scripts/auth","title":"auth","description":"The login and registrations system are planned to change. This current solution was used because the goal was just to make it work. Now, we improve.","source":"@site/docs/Architecture/Backend/Flask Scripts/auth.md","sourceDirName":"Architecture/Backend/Flask Scripts","slug":"/Architecture/Backend/Flask Scripts/auth","permalink":"/docs/Architecture/Backend/Flask Scripts/auth","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Architecture/Backend/Flask Scripts/auth.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"api","permalink":"/docs/Architecture/Backend/Flask Scripts/api"},"next":{"title":"check-password","permalink":"/docs/Architecture/Backend/Flask Scripts/check-password"}}');var a=n(4848),t=n(8453);const o={},u=void 0,c={},i=[{value:"auth.py",id:"authpy",level:2}];function l(e){const r={blockquote:"blockquote",code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.p,{children:"The login and registrations system are planned to change. This current solution was used because the goal was just to make it work. Now, we improve."}),"\n",(0,a.jsxs)(r.blockquote,{children:["\n",(0,a.jsx)(r.p,{children:"NOTE: We plan to migrate to Super Tokens authentication solution."}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"authpy",children:"auth.py"}),"\n",(0,a.jsx)(r.p,{children:"The auth.py is used for login and registration, scoreboard fetch, fetch aura points"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:'# auth.py \u2014 Flask blueprint for user registration, login, flag submission, and progress\r\n\r\nfrom flask import Blueprint, request, jsonify\r\nimport sqlite3\r\nimport bcrypt\r\nimport jwt\r\nimport datetime\r\n\r\n# Flask blueprint \u2014 handles all /api/auth routes\r\nauth_bp = Blueprint(\'auth\', __name__, url_prefix=\'/api/auth\')\r\n\r\n# --- Configuration ---\r\nDB_PATH = "<DB_PATH>"  # Path to SQLite database\r\nJWT_SECRET = "<JWT_SECRET>"  # Replace with a secure secret\r\nJWT_ALGORITHM = "HS256"\r\nJWT_EXP_DELTA_SECONDS = 3600 * 24  # Token valid for 1 day\r\n\r\n\r\n# --- Helper function ---\r\ndef get_db():\r\n    """Returns a SQLite connection with row access by column name."""\r\n    conn = sqlite3.connect(DB_PATH)\r\n    conn.row_factory = sqlite3.Row\r\n    return conn\r\n\r\n\r\n# --- Route: User Registration ---\r\n@auth_bp.route("/register", methods=["POST"])\r\ndef register():\r\n    """\r\n    Registers a new user with username, email, and password.\r\n    Passwords are hashed using bcrypt.\r\n    """\r\n    data = request.json\r\n    username = data.get("username")\r\n    email = data.get("email")\r\n    password = data.get("password")\r\n\r\n    if not username or not email or not password:\r\n        return jsonify({"success": False, "message": "Username, email and password required"}), 400\r\n\r\n    hashed_pw = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\r\n\r\n    conn = get_db()\r\n    cur = conn.cursor()\r\n\r\n    try:\r\n        # Prevent duplicate usernames or emails\r\n        cur.execute("SELECT 1 FROM users WHERE username = ? OR email = ?", (username, email))\r\n        if cur.fetchone():\r\n            return jsonify({"success": False, "message": "Username or email already exists"}), 409\r\n\r\n        # Insert new user\r\n        cur.execute("INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)", \r\n                    (username, email, hashed_pw))\r\n        conn.commit()\r\n    except sqlite3.IntegrityError:\r\n        return jsonify({"success": False, "message": "Username or email already exists"}), 409\r\n    finally:\r\n        conn.close()\r\n\r\n    return jsonify({"success": True, "message": "User registered successfully"}), 201\r\n\r\n\r\n# --- Route: User Login ---\r\n@auth_bp.route("/login", methods=["POST"])\r\ndef login():\r\n    """\r\n    Authenticates a user and returns a JWT token for subsequent requests.\r\n    """\r\n    data = request.json\r\n    username = data.get("username")\r\n    password = data.get("password")\r\n\r\n    if not username or not password:\r\n        return jsonify({"success": False, "message": "Username and password required"}), 400\r\n\r\n    conn = get_db()\r\n    cur = conn.cursor()\r\n    cur.execute("SELECT password_hash FROM users WHERE username = ?", (username,))\r\n    row = cur.fetchone()\r\n    conn.close()\r\n\r\n    if not row:\r\n        return jsonify({"success": False, "message": "Invalid username or password"}), 401\r\n\r\n    password_hash = row["password_hash"]\r\n\r\n    if not bcrypt.checkpw(password.encode(), password_hash):\r\n        return jsonify({"success": False, "message": "Invalid username or password"}), 401\r\n\r\n    # Generate JWT token\r\n    payload = {\r\n        "username": username,\r\n        "exp": datetime.datetime.utcnow() + datetime.timedelta(seconds=JWT_EXP_DELTA_SECONDS)\r\n    }\r\n    token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)\r\n\r\n    return jsonify({"success": True, "token": token}), 200\r\n\r\n\r\n# --- Route: Submit Flag ---\r\n@auth_bp.route("/submit", methods=["POST"])\r\ndef submit_flag():\r\n    """\r\n    Authenticated route for submitting flags.\r\n    Updates user progress and awards aura points.\r\n    """\r\n    auth_header = request.headers.get("Authorization")\r\n    if not auth_header or not auth_header.startswith("Bearer "):\r\n        return jsonify({"success": False, "message": "Missing or invalid token"}), 401\r\n\r\n    try:\r\n        token = auth_header.split(" ")[1]\r\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])\r\n        username = payload["username"]\r\n    except jwt.ExpiredSignatureError:\r\n        return jsonify({"success": False, "message": "Token expired"}), 401\r\n    except jwt.InvalidTokenError:\r\n        return jsonify({"success": False, "message": "Invalid token"}), 401\r\n\r\n    # Validate input\r\n    data = request.json\r\n    game = data.get("game")\r\n    level = data.get("level")\r\n    submitted_flag = data.get("flag")\r\n\r\n    if not game or not level or not submitted_flag:\r\n        return jsonify({"success": False, "message": "Missing game, level or flag"}), 400\r\n\r\n    conn = get_db()\r\n    cur = conn.cursor()\r\n\r\n    try:\r\n        # Fetch level info\r\n        cur.execute("SELECT flag, aura_points FROM levels WHERE game = ? AND level = ?", (game, level))\r\n        level_data = cur.fetchone()\r\n        if not level_data:\r\n            return jsonify({"success": False, "message": "Level not found"}), 404\r\n\r\n        correct_flag = level_data["flag"]\r\n        if submitted_flag.strip() != correct_flag.strip():\r\n            return jsonify({"success": False, "message": "Incorrect flag"}), 403\r\n\r\n        # Check if already completed\r\n        cur.execute("SELECT 1 FROM progress WHERE username = ? AND game = ? AND level = ?", \r\n                    (username, game, level))\r\n        if cur.fetchone():\r\n            return jsonify({\r\n                "success": True,\r\n                "message": "Flag already submitted",\r\n                "aura_points": 0,\r\n                "game": game,\r\n                "level": level\r\n            })\r\n\r\n        # Insert new completion\r\n        aura_points = level_data["aura_points"] or 10\r\n        cur.execute("INSERT INTO progress (username, game, level, aura_points) VALUES (?, ?, ?, ?)",\r\n                    (username, game, level, aura_points))\r\n        conn.commit()\r\n\r\n        return jsonify({\r\n            "success": True,\r\n            "message": "Correct flag!",\r\n            "aura_points": aura_points,\r\n            "game": game,\r\n            "level": level\r\n        })\r\n\r\n    except Exception as e:\r\n        conn.rollback()\r\n        return jsonify({"success": False, "message": str(e)}), 500\r\n    finally:\r\n        conn.close()\r\n\r\n\r\n# --- Route: Get User Progress ---\r\n@auth_bp.route("/myprogress", methods=["GET"])\r\ndef my_progress():\r\n    """\r\n    Returns all progress for the authenticated user.\r\n    """\r\n    auth_header = request.headers.get("Authorization")\r\n    if not auth_header or not auth_header.startswith("Bearer "):\r\n        return jsonify({"success": False, "message": "Missing or invalid token"}), 401\r\n\r\n    try:\r\n        token = auth_header.split(" ")[1]\r\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])\r\n        username = payload["username"]\r\n\r\n        conn = get_db()\r\n        cur = conn.cursor()\r\n        cur.execute("SELECT game, level FROM progress WHERE username = ? ORDER BY game, level", (username,))\r\n        progress = [{"series": row["game"], "level": row["level"].replace("level", "")} for row in cur.fetchall()]\r\n\r\n        return jsonify({"success": True, "progress": progress}), 200\r\n\r\n    except jwt.ExpiredSignatureError:\r\n        return jsonify({"success": False, "message": "Token expired"}), 401\r\n    except jwt.InvalidTokenError:\r\n        return jsonify({"success": False, "message": "Invalid token"}), 401\r\n    except Exception as e:\r\n        return jsonify({"success": False, "message": str(e)}), 500\r\n    finally:\r\n        conn.close()\r\n\r\n\r\n# --- Route: Get Total Aura Points ---\r\n@auth_bp.route("/aura_points", methods=["GET"])\r\ndef get_aura_points():\r\n    """\r\n    Returns total aura points from challenges and academy tasks.\r\n    """\r\n    auth_header = request.headers.get("Authorization")\r\n    if not auth_header or not auth_header.startswith("Bearer "):\r\n        return jsonify({"success": False, "message": "Missing or invalid token"}), 401\r\n\r\n    try:\r\n        token = auth_header.split(" ")[1]\r\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])\r\n        username = payload["username"]\r\n\r\n        conn = get_db()\r\n        cur = conn.cursor()\r\n\r\n        # Aura from challenges\r\n        cur.execute("SELECT COALESCE(SUM(aura_points), 0) as challenge_aura FROM progress WHERE username = ?", (username,))\r\n        challenge_aura = cur.fetchone()["challenge_aura"]\r\n\r\n        # Aura from academy tasks\r\n        cur.execute("""\r\n            SELECT COALESCE(SUM(at.aura_points), 0) as academy_aura\r\n            FROM academy_user_progress ap\r\n            JOIN users u ON ap.user_id = u.id\r\n            JOIN academy_tasks at ON ap.task_id = at.id\r\n            WHERE u.username = ? AND ap.completed = 1\r\n        """, (username,))\r\n        academy_aura = cur.fetchone()["academy_aura"]\r\n\r\n        total = challenge_aura + academy_aura\r\n        return jsonify({"success": True, "total_aura": total}), 200\r\n\r\n    except Exception as e:\r\n        return jsonify({"success": False, "message": str(e)}), 500\r\n    finally:\r\n        conn.close()\r\n\r\n\r\n# --- Route: Scoreboard ---\r\n@auth_bp.route("/scoreboard", methods=["GET"])\r\ndef get_scoreboard():\r\n    """\r\n    Returns a leaderboard of users sorted by total aura points.\r\n    """\r\n    try:\r\n        conn = get_db()\r\n        cur = conn.cursor()\r\n        cur.execute("SELECT username, COALESCE(SUM(aura_points),0) AS aura_points FROM progress GROUP BY username ORDER BY aura_points DESC")\r\n        rows = cur.fetchall()\r\n        scoreboard = [{"username": row["username"], "aura_points": row["aura_points"] or 0} for row in rows]\r\n        return jsonify(scoreboard), 200\r\n    except Exception as e:\r\n        return jsonify({"success": False, "message": str(e)}), 500\r\n    finally:\r\n        conn.close()\r\n\n'})})]})}function d(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>u});var s=n(6540);const a={},t=s.createContext(a);function o(e){const r=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function u(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(t.Provider,{value:r},e.children)}}}]);