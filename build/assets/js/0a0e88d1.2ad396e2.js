"use strict";(globalThis.webpackChunkwargames_docs=globalThis.webpackChunkwargames_docs||[]).push([[4150],{6964:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Architecture/Backend/Flask Scripts/flag","title":"flag","description":"flag.py","source":"@site/docs/Architecture/Backend/Flask Scripts/flag.md","sourceDirName":"Architecture/Backend/Flask Scripts","slug":"/Architecture/Backend/Flask Scripts/flag","permalink":"/docs/Architecture/Backend/Flask Scripts/flag","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Architecture/Backend/Flask Scripts/flag.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"check-password","permalink":"/docs/Architecture/Backend/Flask Scripts/check-password"},"next":{"title":"server","permalink":"/docs/Architecture/Backend/Flask Scripts/server"}}');var t=n(4848),a=n(8453);const o={},i=void 0,l={},c=[{value:"flag.py",id:"flagpy",level:2}];function u(e){const r={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{id:"flagpy",children:"flag.py"}),"\n",(0,t.jsx)(r.p,{children:"This script is used for flag submittiong, saving progress."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:'# flag.py \u2014 Flask blueprint for flag submission and progress tracking\r\n\r\nfrom flask import Blueprint, request, jsonify\r\nimport sqlite3\r\nimport jwt\r\n\r\n# Flask blueprint \u2014 handles all /api/flags routes\r\nflag_bp = Blueprint("flag", __name__, url_prefix="/api/flags")\r\n\r\nDB_PATH = "<DB_PATH>"\r\nJWT_SECRET = "<JWT_SECRET>"\r\nJWT_ALGORITHM = "HS256"\r\n\r\n# Import flag data mapping (series -> levels -> flags)\r\nfrom levels import flag_map\r\n\r\n\r\n# --- Database Helper ---\r\ndef get_db():\r\n    """Creates and returns a database connection."""\r\n    conn = sqlite3.connect(DB_PATH)\r\n    conn.row_factory = sqlite3.Row\r\n    return conn\r\n\r\n\r\n# --- Route: Submit Flag ---\r\n@flag_bp.route("/submit", methods=["POST"])\r\ndef submit_flag():\r\n    """\r\n    Receives a submitted flag, verifies it, and records player progress.\r\n    Requires a valid JWT token in the Authorization header.\r\n    """\r\n\r\n    # --- Authorization check ---\r\n    auth_header = request.headers.get("Authorization", None)\r\n    if not auth_header:\r\n        return jsonify({"success": False, "message": "Missing authorization header"}), 401\r\n\r\n    # Validate "Bearer <token>" format\r\n    parts = auth_header.split()\r\n    if len(parts) != 2 or parts[0].lower() != "bearer":\r\n        return jsonify({"success": False, "message": "Invalid authorization header"}), 401\r\n\r\n    token = parts[1]\r\n    try:\r\n        # Decode the JWT to extract the username\r\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])\r\n        username = payload.get("username")\r\n    except jwt.ExpiredSignatureError:\r\n        return jsonify({"success": False, "message": "Token expired"}), 401\r\n    except jwt.InvalidTokenError:\r\n        return jsonify({"success": False, "message": "Invalid token"}), 401\r\n\r\n    # --- Validate request body ---\r\n    data = request.json\r\n    series = data.get("series")\r\n    level = str(data.get("level"))\r\n    submitted_flag = data.get("flag")\r\n\r\n    if not all([series, level, submitted_flag]):\r\n        return jsonify({"success": False, "message": "Missing fields"}), 400\r\n\r\n    # --- Check flag correctness ---\r\n    correct_flag = flag_map.get(series, {}).get(level)\r\n    if not correct_flag:\r\n        return jsonify({"success": False, "message": "Invalid series or level"}), 400\r\n\r\n    if submitted_flag != correct_flag:\r\n        return jsonify({"success": False, "message": "Incorrect flag"}), 401\r\n\r\n    # --- Database operations ---\r\n    conn = get_db()\r\n    cur = conn.cursor()\r\n\r\n    # Prevent duplicate submissions\r\n    cur.execute(\r\n        "SELECT 1 FROM user_progress WHERE username = ? AND series = ? AND level = ?",\r\n        (username, series, level)\r\n    )\r\n    if cur.fetchone():\r\n        conn.close()\r\n        return jsonify({"success": True, "message": "Already submitted"}), 200\r\n\r\n    # Award aura points (example logic)\r\n    aura_points = 10 if level == "0" else 20\r\n\r\n    # Record progress in database\r\n    cur.execute("""\r\n        INSERT INTO user_progress (username, series, level, aura_points)\r\n        VALUES (?, ?, ?, ?)\r\n    """, (username, series, level, aura_points))\r\n\r\n    conn.commit()\r\n    conn.close()\r\n\r\n    # Determine if this is the last level of the series\r\n    all_levels = list(flag_map[series].keys())\r\n    is_last = level == max(all_levels, key=int)\r\n\r\n    # --- Response ---\r\n    return jsonify({\r\n        "success": True,\r\n        "message": "Flag accepted",\r\n        "aura_points": aura_points,\r\n        "confetti": is_last  # used for celebration animation in frontend\r\n    }), 200\r\n\r\n\r\n# --- Route: Get User Progress ---\r\n@flag_bp.route("/progress", methods=["GET"])\r\ndef get_progress():\r\n    """\r\n    Returns all completed levels for the authenticated user.\r\n    Requires a valid JWT token.\r\n    """\r\n\r\n    # --- Authorization check ---\r\n    auth_header = request.headers.get("Authorization", None)\r\n    if not auth_header:\r\n        return jsonify({"success": False, "message": "Missing authorization header"}), 401\r\n\r\n    parts = auth_header.split()\r\n    if len(parts) != 2 or parts[0].lower() != "bearer":\r\n        return jsonify({"success": False, "message": "Invalid authorization header"}), 401\r\n\r\n    token = parts[1]\r\n    try:\r\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])\r\n        username = payload.get("username")\r\n    except jwt.ExpiredSignatureError:\r\n        return jsonify({"success": False, "message": "Token expired"}), 401\r\n    except jwt.InvalidTokenError:\r\n        return jsonify({"success": False, "message": "Invalid token"}), 401\r\n\r\n    # --- Fetch user progress ---\r\n    conn = get_db()\r\n    cur = conn.cursor()\r\n    cur.execute("SELECT series, level FROM user_progress WHERE username = ?", (username,))\r\n    rows = cur.fetchall()\r\n    conn.close()\r\n\r\n    # --- Response ---\r\n    return jsonify({\r\n        "success": True,\r\n        "completed_levels": [{"series": r["series"], "level": int(r["level"])} for r in rows]\r\n    })\r\n\n'})})]})}function d(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>i});var s=n(6540);const t={},a=s.createContext(t);function o(e){const r=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(a.Provider,{value:r},e.children)}}}]);